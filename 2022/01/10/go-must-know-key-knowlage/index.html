<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Go语言必须需要掌握的相关知识 | Eddison</title><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/liuzexin.github.io/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/liuzexin.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liuzexin.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liuzexin.github.io/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言必须需要掌握的相关知识</h1><a id="logo" href="/liuzexin.github.io/.">Eddison</a><p class="description">欢迎来到这里交流'</p></div><div id="nav-menu"><a class="current" href="/liuzexin.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/liuzexin.github.io/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go语言必须需要掌握的相关知识</h1><div class="post-meta">2022-01-10</div><div class="post-content"><blockquote>
<p>本文是在实际开发中所遇到的问题以及知识点进行了罗列,也和其他的编程语言进行了比较.</p>
</blockquote>
<h2 id="Go中不支持的语法">Go中不支持的语法</h2>
<p>1.Go不支持三元运算符<br>
因为Go的设计者认为,三元运算很长的表达式中会有些难以理解,所以只能使用if-else控制</p>
<p>2.Go不支持结构体常量.</p>
<p>3.<code>++</code>运算符只能放在变量后面,而且不能被用于复杂表达式嵌套,但可以用于for循环的使用.这一点对类C语言的改进还是很重要的,使代码更加清晰.</p>
<p>4.if条件只能判断bool类型,或者表达式,int,float,string等类型无法做判断.也没有隐式的类型转换.</p>
<h2 id="TestMain">TestMain</h2>
<p>在编写单元测试时可以使用TestMain在一个包中声明一个测试的主函数,每当测试该包时,可以执行一些初始化的操作例如涉及到数库日志文件路径初始化等可以放到该函数下.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123; </span><br><span class="line">  	 mysql.InitDbPool()</span><br><span class="line">    retCode := m.Run()</span><br><span class="line">  	mysql.ReleasePool()</span><br><span class="line">    os.Exit(retCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map与slice引用问题">map与slice引用问题</h2>
<p>Go语言当中存在引用的问题,<strong>但是没有引用传递</strong>,因为map和channel类型需要注意是指向runtime 类型的指针.</p>
<p>因此在运行中传参与指针传参一样,改变map,slice当中的值,该实际参数原来的值也会改变.<br>
map,slice能够在函数当中更改,是因为slice本身是值拷贝,而内部保留了对底层数据结构的的引用.</p>
<blockquote>
<p>Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s)<span class="comment">//0xc42000a260</span></span><br><span class="line">	t(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s)<span class="comment">//0xc42000a260</span></span><br><span class="line">	<span class="comment">//这时的s是 [9900 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s[<span class="number">0</span>]) <span class="comment">//0xc42000e260</span></span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">9900</span>     <span class="comment">//将实参改为了 [9900 2]</span></span><br><span class="line">	s = []<span class="type">int</span>&#123;<span class="number">8800</span>&#125; <span class="comment">//这个时候重新修改参数,不会影响实际参数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s)<span class="comment">//0xc42000a280</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中对<code>t</code>函数当中的slice重新赋值,不会影响实参,因为<code>t</code>函数的<code>s</code>变量有自己单独的地址.<br>
<strong>小结:slice,map,channel是值传递,因为实参和形参的地址不是同一地址,但是内部保存了对原来内容的引用,修改内容会影响实参.本质是实参和形参都是独立的指针,指向了同一块数据,实际更改其实都是对数据内容的更改.</strong></p>
<h3 id="map与slice补充">map与slice补充</h3>
<p>1.<code>[]T</code> 与 <code>[]interface</code>不能直接转换,官方文档说的是这两种在内存当中的存储是不一样的,因此不能只接转换,<br>
<a target="_blank" rel="noopener" href="https://golang.org/doc/faq#convert_slice_of_interface">详细请点击</a>.</p>
<p>2.map是非原子操作类型,因此在多协程操作下无法保证Map类型的安全性.</p>
<p>3.如果需要深拷贝一个map或者slice类型,那么需要新建一个map,通过遍历要拷贝的map复制到新map当中.</p>
<h2 id="array-类型">array 类型</h2>
<p>Go中还有一个不起眼的类型是array类型:数字类型组成,且有固定的长度.<br>
一定要和map,slice以及channel区分开他们是引用类型.</p>
<p>array和上述类型存在本质区别,array类型是作为<strong>值类型</strong>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	t(a)</span><br><span class="line">	fmt.Println(a)<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(a [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a)<span class="comment">//[10 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建方法时receiver是结构体还是指针">创建方法时receiver是结构体还是指针?</h2>
<p>官方推荐如果需要改变receiver,那么就定义为指针,如果不需要进行修改那么就定义为值.<br>
如果结构体相当大,那么考虑采用只指针.<br>
如果有些方法需要修改receiver,那么需要统一的将方法设置为指针传递.</p>
<p><strong>注意</strong>:指针receiver所有的方法包含指针的receiver和非指针的receiver.而非指针的receiver只包含非指针receiver的方法集.</p>
<h2 id="关于原子操作">关于原子操作</h2>
<p>Go很方便提供了sync/atomic包保证访问内存对象的原子性.<br>
但是这是一种简单的方式,更高级的是采用协程配合管道来实现原子操作.<br>
这样的方式设计起来和之前的方式不同.需要关注管道数据中流向,因此体出了更高设计理念.<br>
不要使用共享内存方式进行通信,相反通过通信实现共享内存.<br>
Do not communicate by sharing memory. Instead, share memory by communicating.</p>
<p>不由自已的赞叹Go的设计理念,提供更先进的编程方式.</p>
<h2 id="接口类型的实现">接口类型的实现</h2>
<p>接口类型有两个元素组成一个是类型一个是值.如果将int 3存储到空接口当中那么,实质上这个接口的类型为int,值为3.<br>
声明一个接口类型类型默认是nil,值默认是nil.<br>
当我们拿一个接口类型和nil比较的时候需要注意的是,nil接口类型是有nil类型和nil的值组成.<br>
只要接口类型中的值或者类型不等于nil那么,就不能正确判断.<br>
尤其是在返回自定义error类型的时候,这样是不能按照理解的意思去执行的.所以要返回一个接口类型的值如果为空,那么必须返回为nil.</p>
<p>示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">error</span></span><br><span class="line">	test <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnErr</span><span class="params">()</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> mErr *MyError = <span class="literal">nil</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(mErr), reflect.ValueOf(mErr))<span class="comment">//*main.MyError &lt;nil&gt;</span></span><br><span class="line">	<span class="keyword">if</span> mErr == <span class="literal">nil</span> &#123;<span class="comment">//不是接口类型能正常判断</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;=========== error true&quot;</span>)<span class="comment">//输出=========== error true</span></span><br><span class="line">	&#125;</span><br><span class="line">	e = mErr</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.TypeOf(e), reflect.ValueOf(e))<span class="comment">//*main.MyError &lt;nil&gt; </span></span><br><span class="line">	<span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;=========== error true&quot;</span>)<span class="comment">//没有输出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子的<code>e</code>类型已经改变,变为 <code>*MyError</code> 类型,但值是<code>nil</code>所以不能等于<code>nil</code>.</p>
<h2 id="map-string-interface">map[string]interface{}</h2>
<p>由弱类型语言转换到强类型的语言,必须有一个概念,类型不能轻易的变化,不能随意滥用.<br>
例如PHP语言关联数组可以用于很多场景,因为PHP语言弱类型的特性这点优势很大.<br>
但是对于Go语言而言,没有那么方便.</p>
<p>在关联数组可以简单的在GO中可以转换map[string]interface{}.<br>
PHP:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [</span><br><span class="line">	<span class="string">&quot;a&quot;</span> =&gt; <span class="number">10</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := map[string]interface&#123;&#125;&#123;</span><br><span class="line">	&quot;a&quot; : 10,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用这个值时</p>
<p>PHP:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr[<span class="string">&quot;a&quot;</span>] == <span class="number">10</span>)&#123;</span><br><span class="line">	<span class="comment">//do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> arr[<span class="string">&quot;a&quot;</span>].(<span class="type">int</span>) == <span class="number">10</span>&#123;</span><br><span class="line">	<span class="comment">//do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Go中使用类型断言来告诉编译器这是一个int类型,反观PHP当中没有这样的操作,因为PHP中不同的类型是可以比较的.</p>
<p>再来看一个二维数组例子,实际上会使阅读更加困难.</p>
<p>PHP:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = [</span><br><span class="line">	<span class="string">&quot;b&quot;</span> =&gt; [</span><br><span class="line">		<span class="string">&quot;c&quot;</span> =&gt; <span class="number">0</span></span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">if</span>(arr[<span class="string">&quot;b&quot;</span>][<span class="string">&quot;c&quot;</span>] == <span class="number">10</span>)&#123;</span><br><span class="line">	<span class="comment">//do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr := map[string]interface&#123;&#125;&#123;</span><br><span class="line">	&quot;b&quot; : map[string]interface&#123;&#125;&#123;</span><br><span class="line">		&quot;c&quot; : 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if arr[&quot;b&quot;].(map[string]interface&#123;&#125;)[&quot;c&quot;].(int) == 10&#123;</span><br><span class="line">	//do somthing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上述的表达式一个简单的取值行为需要多次类型的断言.整个代码变的很长,且违背了Go语言的简洁性.因此map[string]interface{}的乱用,会使代码变的难以阅读,而且编译时不容易发现错误,转而导致运行时才可以发现错误.</p>
<h2 id="package的相关问题">package的相关问题</h2>
<p>1.内部包<br>
内部包规则定义:导入的路径包含&quot;internal&quot;,当需要导入的代码不与&quot;internal&quot;父级目录为同一目录的不允许导入.</p>
<blockquote>
<p>An import of a path containing the element “internal” is disallowed if the importing code is outside the tree rooted at the parent of the “internal” directory.</p>
</blockquote>
<p>例: /a/b/c/internal/d/e/f,f包可以被/a/b/c导入,但无法被/a/b/g导入.<br>
2.包目录<br>
查找路径:<br>
当前包下的vendor目录。<br>
向上级目录查找vendor目录。<br>
在<code>$GOPATH</code>下面查找依赖包。<br>
在<code>$GOROOT</code>目录下查找</p>
<p>PS:<code>GOOPATH</code>为WorkSpace,<code>GOROOT</code>为Go的安装目录.<br>
vendor可以嵌套vendor目录,这项新特性在Go 1.5以后支持,目的是为了解决不同工程依赖不同的包版本的问题.</p>
<p>目录如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">├── css_test.go</span><br><span class="line">├── main.go</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br><span class="line">    │   ├── andybalholm</span><br><span class="line">    │   │   └── cascadia</span><br><span class="line">    │   │       ├── LICENSE</span><br><span class="line">    │   │       ├── parser.go</span><br><span class="line">    │   │       ├── README.md</span><br><span class="line">    │   │       └── selector.go</span><br><span class="line">    │   └── tdewolff</span><br><span class="line">    │       ├── buffer</span><br><span class="line">    │       │   ├── buffer.go</span><br><span class="line">	..................</span><br><span class="line">    │       └── parse</span><br><span class="line">    │           ├── common.go</span><br><span class="line">    │           ├── css</span><br><span class="line">    │           │   ├── hash.go</span><br><span class="line">    │           │   ├── lex.go</span><br><span class="line">    │           │   ├── parse.go</span><br><span class="line">    │           │   ├── README.md</span><br><span class="line">    │           │   └── util.go</span><br><span class="line">    │           ├── LICENSE.md</span><br><span class="line">    │           ├── README.md</span><br><span class="line">    │           └── util.go</span><br><span class="line">    ├── golang.org</span><br><span class="line">    │   └── x</span><br><span class="line">    │       └── net</span><br><span class="line">    │           └── html</span><br><span class="line">    │               ├── atom</span><br><span class="line">    │               │   ├── atom.go</span><br><span class="line">    │               │   ├── gen.go</span><br><span class="line">    │               │   └── table.go</span><br><span class="line">    │               ├── const.go</span><br><span class="line">		......</span><br><span class="line">    └── vendor.json</span><br></pre></td></tr></table></figure>
<p>3.使用go get时,安装的是包,如果要安装指定地址下所有包可以使用 <code>go get test.com/...</code> 安装<code>test.com</code>域名下的所有包,如果直接<code>go get test.com/</code> 会报<code>no buildable Go source files</code>的错.</p>
<h2 id="字符常量">字符常量</h2>
<p>我们在Go中可以表示写一个表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time := <span class="number">1</span> * time.Second</span><br></pre></td></tr></table></figure>
<p>注意这时的<code>1</code>是一个无类型常量,而它的类型根据他的上下文确定(An untyped constant takes the type needed by its context.).<br>
所以<code>1</code>就变成了<code>time.Duration</code>这个类型,这个类型实质是<code>int64</code>.</p>
<h2 id="panic-与-recover">panic 与 recover</h2>
<p>开发时,需要留意panic与recover的恢复机制:<br>
假设在函数<code>F</code>运行时发生panic,任意在<code>F</code>函数当中被defer函数会正常执行.<br>
然后<code>F</code>函数调用者defer的函数被执行,在执行的gorutine内如此循环到最上层,然后程序终止.</p>
<p>如果函数<code>F</code>defer的函数<code>G</code>中有recover函数,且没有新的异常抛出,那么程序会恢复执行.<br>
只要在<code>G</code>之前defer的函数截止被执行,然后<code>F</code>函数返回调用方,<code>F</code>函数执行终止.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;done&quot;</span>)  <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	log.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="零值定义">零值定义</h2>
<p>Bool:false<br>
数字类型:0<br>
strings:“”<br>
pointers, functions, interfaces, slices, channels, and maps: nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; i <span class="type">int</span>; f <span class="type">float64</span>; next *T &#125;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line"><span class="comment">//对应的空值:</span></span><br><span class="line">t.i == <span class="number">0</span></span><br><span class="line">t.f == <span class="number">0.0</span></span><br><span class="line">t.next == <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h2 id="不能对map-key-运算地址操作符">不能对map[key]运算地址操作符&amp;</h2>
<p>这时根据Map底层数据结构定义的,Map在内存当中由许多的bucket组成,当Map内部元素增加,删除或者更新,bucket会被重新排放.<br>
因此Map中的元素没有固定的地址,因此取地址运算符是错误的.<br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Tl7mi9QmLns">油管Map详解视频地址</a></p>
<h2 id="string-rune到底是什么">string,rune到底是什么</h2>
<p>string底层是由字节数组组成([]byte),直接索引会造成读取错误.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const str := `⌘`</span><br><span class="line">for i := 0; i &lt; len(str); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%x &quot;, str[i])// e2 8c 98</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个UTF8是有可变长的代码点(Codepoint)组成,PHP内部是与其一致的,但是JS内部索引会获得’字符.’</p>
<p>而rune本质是一个int32类型,大家都知道UTF8是由一个到三个字节(Codepoint)组成.足够存储一个UTF8字符.<br>
如果真正需要索引字符可以通过[]rune去读取每个UTF8字符.</p>
<p>补充:<br>
Go source code is always UTF-8.Go源码是UTF8,一个字符串可以拥有任意字节,缺少字节转义的字符串字符,就会一直保持有效的UTF8序列.<br>
这些序列代表着Unicode代码点,被称作runes.不保证字符串中的字符是标准的UTF8字符.<br>
A string holds arbitrary bytes.<br>
A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.<br>
Those sequences represent Unicode code points, called runes.<br>
No guarantee is made in Go that characters in strings are normalized.</p>
<h2 id="调试">调试</h2>
<p>编译类语言一定要学会Debug,C语言有强大的gdb进行调试,gdb对于go支持情况不太好,但是也可以用.gdb的调试,<a target="_blank" rel="noopener" href="https://golang.org/doc/gdb">官方博客</a>写的很清楚.<br>
还有一个很好用的Go调试工具叫做<a target="_blank" rel="noopener" href="https://github.com/derekparker/delve/">DELVE</a>,命令保持了与gdb一致的风格但是对go语言支持更好一些.</p>
<h2 id="multi-part表单处理的问题">multi-part表单处理的问题</h2>
<p>处理表达请求时代码,NewWriter实体要及时调用Close方法,<strong>不要使用defer</strong>,否则会导致请求体表单丢失边界,引起服务端解析错误.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">w := multipart.NewWriter(buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> params &#123;</span><br><span class="line">	_ = w.WriteField(key, val)</span><br><span class="line">&#125;</span><br><span class="line">w.Close()<span class="comment">//不要使用defer</span></span><br><span class="line">request,_ := http.NewRequest(<span class="string">&quot;post&quot;</span>, postUrl, buffer)</span><br></pre></td></tr></table></figure>
<p>解析的时候需要注意的是,调用方法要使用<code>r.ParseMultipartForm(1024 * 1024)</code>,不要使用<code>r.ParseForm()</code>.</p>
<h2 id="常用技巧归总">常用技巧归总</h2>
<p>1.在判断map是否存在key功能和PHP中的isset函数用法是一致的,即如果存在key,但是value值为nil也会返回true.</p>
<p>2.[]byte转字符串:string(byteArr[:])</p>
<p>3.根据<a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html#mixed-caps">命名规则</a>需要按照effctive go的方式进行编写.例如在PHP当中的<code>define(&quot;TEST&quot;, true)</code>这样的定义在GO当中是不被推荐的,推荐的是驼峰式命名规则.</p>
<p>4.string.Split可以分割字符串  转换字符串数组</p>
<p>5.defer可以在函数返回(return)之后执行.</p>
<p>6.判断一个值到底是不是空需要具体定,如果判断map,slice,channel通过len()函数判断.</p>
<p>7.自定义的结构体可以通过这样的形式判断是否为空 : == 或者  reflect.DeepEqual()包括所有的属性都会深度遍历进行比较.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	s1 := MyStruct&#123;&#125; <span class="comment">//空对象</span></span><br><span class="line">	s2 := MyStruct&#123; a:<span class="number">10</span> &#125; </span><br><span class="line">	<span class="keyword">if</span> s2 != s1&#123;</span><br><span class="line">		<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针类型的判断只有当两个指针指向同一个对象时,才会为true.<br>
8. Json 解析对应的类型:</p>
<ul>
<li><code>bool</code> for JSON booleans,</li>
<li><code>float64</code> for JSON numbers,注意这里JavaScript定义的数字类型用float类型表示.</li>
<li><code>string</code> for JSON strings, and</li>
<li><code>nil</code> for JSON null.</li>
</ul>
<p>9.switch 与case语句对齐(PS:case里可以放置表达式)</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/liuzexin.github.io/2024/10/19/kmp/">KMP算法-php实现</a><a class="next" href="/liuzexin.github.io/2021/11/20/manacher/">Manacher算法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://liuzexin.github.io/liuzexin.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpg"/></a><p>Stay foolish, stay hungry.</p><a class="info-icon" href="https://github.com/liuzexin" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://blog.csdn.net/lzx_victory?type=blog" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/liuzexin.github.io/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">线程,进程,协程</a> <a href="/liuzexin.github.io/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/linux-performance/">Linux 性能分析</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/kmp/">KMP算法-php实现</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2022/01/10/go-must-know-key-knowlage/">Go语言必须需要掌握的相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/11/20/manacher/">Manacher算法</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/10/17/algorithm/">算法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/09/17/tcp-nagle/">TCP Nagle 与TCP Delayed ACK性能调研</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/liuzexin.github.io/." rel="nofollow">Eddison.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/liuzexin.github.io/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/liuzexin.github.io/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/liuzexin.github.io/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/liuzexin.github.io/js/smartresize.js?v=1.0.0"></script></div></body></html>