<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>算法小结 | Eddison</title><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/liuzexin.github.io/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/liuzexin.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liuzexin.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liuzexin.github.io/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法小结</h1><a id="logo" href="/liuzexin.github.io/.">Eddison</a><p class="description">欢迎来到这里交流'</p></div><div id="nav-menu"><a class="current" href="/liuzexin.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/liuzexin.github.io/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">算法小结</h1><div class="post-meta">2021-10-17</div><div class="post-content"><h1>数据结构</h1>
<h2 id="链表">链表</h2>
<h3 id="虚拟节点">虚拟节点</h3>
<p>链表设置虚拟头结点dummyhead，这样对链表来说，第一个元素就是dummyhead的next所对应的节点元素，而不是dummyhead所对应的节点元素。</p>
<p>dummyhead位置所对应的元素是根本不存在的，这只是未来我们编写逻辑方便而出现的一个虚拟头结点。</p>
<p>dummyhead就是索引为0的这个位置的元素的前一个节点。当我们有了dummyhead后，为链表添加一个元素，就不需要对头结点进行特殊处理了，只需要找到等待添加位置的前一个位置的节点，</p>
<p>此时对于链表来说，所有位置都有前一个节点。</p>
<h3 id="反转法">反转法</h3>
<p><img src="../img/algorithm/Image.gif" alt="翻转"><br>
反转的方法很简单:切出一个要反转的头节点,next置为null,作为尾节点的开始.然后不停的将头结点放入尾节点之前.</p>
<h3 id="头插法">头插法</h3>
<p>这种方法类似于麻将洗牌,可以将自己的手牌当做链表,反转动作可以认为,我们要将手牌中的一张牌插入前面的牌的位置当中.<br>
1.拿出这张牌<br>
2.此时缺了空位,待插入位置整体向后移动链接空位之后的牌,腾出待插入的位置.<br>
3.插入的牌链接空位之后的牌<br>
4.头牌链接插入的牌<br>
<strong>图片以反转链表II的拿过来,真正的翻转链表需要g是指向dummynode.</strong><br>
<img src="../img/algorithm/Image.png" alt="虚拟节点"><br>
首先要构建一个dumynode,然后以插牌的方式进行构建.g不会动只有p在动,这与上述的反转法,是有区别的.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(p.next != <span class="literal">nil</span>) &#123;</span><br><span class="line">            ListNode removed = p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next = g.next;</span><br><span class="line">            g.next = removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="广度遍历">广度遍历</h3>
<p>1.非递归用,双向链表或者队列实现.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printLevelorder(tree)</span><br><span class="line">1) Create an empty queue q</span><br><span class="line">2) temp_node = root /*start from root*/</span><br><span class="line">3) Loop while temp_node is not NULL</span><br><span class="line">    a) print temp_node-&gt;data.</span><br><span class="line">    b) Enqueue temp_node’s children (first left then right children) to q</span><br><span class="line">    c) Dequeue a node from q and assign it’s value to temp_node</span><br></pre></td></tr></table></figure>
<p>2.递归很简单,按层级遍历,但是要注意以下发放效率很差,远不如非递归的实现,方法需要改进.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*Function to print level order traversal of tree*/</span><br><span class="line">printLevelorder(tree)</span><br><span class="line">for d = 1 to height(tree)</span><br><span class="line">   printGivenLevel(tree, d);</span><br><span class="line"></span><br><span class="line">/*Function to print all nodes at a given level*/</span><br><span class="line">printGivenLevel(tree, level)</span><br><span class="line">if tree is NULL then return;</span><br><span class="line">if level is 1, then</span><br><span class="line">    print(tree-&gt;data);</span><br><span class="line">else if level greater than 1, then</span><br><span class="line">    printGivenLevel(tree-&gt;left, level-1);</span><br><span class="line">    printGivenLevel(tree-&gt;right, level-1);</span><br></pre></td></tr></table></figure>
<h3 id="深度遍历">深度遍历</h3>
<p>递归版本很简单,非递归的版本.<br>
1.后续遍历,双栈实现.<br>
1.前序遍历,单栈实现.</p>
<h2 id="栈">栈</h2>
<p>入栈的元素可以是数组的下标或者是元素.或者可以设计一种KV的数据结构保存入栈的元素.</p>
<p>涉及到距离的题目一般需要存储下标位置.</p>
<h3 id="单调栈-递减栈">单调栈-递减栈</h3>
<p>站内元素是顺序的,栈顶到栈底整体由小到大.</p>
<h3 id="单调栈-递增栈">单调栈-递增栈</h3>
<p>站内元素是顺序的,栈顶到栈底整体由大到小.</p>
<h2 id="Hash">Hash</h2>
<p>hash结构是一种比较特殊的数据结构,key-value映射的数据结构.一般碰撞发生后语言底层会进行处理.</p>
<h3 id="前缀和">前缀和</h3>
<p>区间的问题几个思路供参考：1、滑动窗口（双指针） 2、前缀和的差 3、线段树（树状数组）</p>
<p>前缀和的差值计算,就涉及到前缀计算结果的存储那么就需要用到hash表结构进行存储.</p>
<h1>操作</h1>
<h2 id="双指针">双指针</h2>
<p>涉及到数组有序的首先要想到的是双指针能不能实现<br>
一般的双指针根据运动方向分成两种:<br>
1.指针一起从左到右移动(前缀和,滑动窗口上面也有介绍)<br>
2.指针从两边向中间移动(二分,交换元素等)</p>
<p>根据移动的速度<br>
可以分为快慢指针,一般快指针运动速度是慢指针的两倍.快慢指针一般在连表当中很常见.</p>
<h3 id="二分">二分</h3>
<p>二分是一种重要的思路,无论是在<strong>有序或者无序的输入中</strong>查找都能用到.<br>
最重要的判断使用二分的方法是:能否将输入元素分成两部分,其中结果只应出现在其中的一部分,递归下去就可以得到结果.</p>
<p><strong>二分法要注意起始的边界,关建点是起始边的界定义,也就是你要二分查找的范围.</strong></p>
<p><strong>二分在二维有序数据的处理本质上是分两拨,在二维数据集里进行分拨查找.</strong></p>
<p>这些概念有点抽象只能自己慢慢体会.</p>
<h4 id="二分模板">二分模板</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">//长度的边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//注意边界条件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// left指针向右移动</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// right指针向左移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么while里写的是 <code>&lt;=</code>, int类型的除法需要注意的是只会向下取整,比如[left =&gt; 0,right =&gt; 1].这样会导致问题的发生.mid=0检查完后,left=1 如果while语句写的是小于,那么会引起问题的产生, right节点就不会检查到了. &lt;= 是确保left与right指针能够相遇,</p>
<p><strong>最主要还是要理解搜索区间的概念,如果按照while &lt;的条件那么有些情况是需要注意的,根据指针移动的规律上下条件有三种:</strong>:<br>
注意 left= 0, right = len(nums)<br>
mid = ( right + left ) /2</p>
<ol>
<li>确定下边界</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while left&lt;right: </span><br><span class="line">    mid &gt;= target: </span><br><span class="line">        right = mid;</span><br><span class="line">    mid &lt; target: </span><br><span class="line">        left = mid + 1 </span><br><span class="line">nums[left] == tartget? left :-1</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>确定上边界</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while left&lt;right:</span><br><span class="line">    mid &lt;= target: </span><br><span class="line">        left = mid + 1; </span><br><span class="line">    mid &gt; target: </span><br><span class="line">        right = mid;</span><br><span class="line">nums[right - 1] == tartget? right - 1: -1</span><br></pre></td></tr></table></figure>
<h1>数学</h1>
<h2 id="模">模</h2>
<h3 id="同余定理">同余定理</h3>
<p>给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。</p>
<p>也就是说(a-b)%m == 0 那么就等价于 a%m == b%m.</p>
<p>这在我们处理涉及到余数相关的问题有着巨大的帮助.</p>
<h1>动态规划</h1>
<h2 id="试用条件">试用条件</h2>
<ul>
<li>
<p>最优化原理:<br>
最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质</p>
</li>
<li>
<p>无后效性<br>
将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
</li>
<li>
<p>子问题重叠<br>
动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。</p>
</li>
</ul>
<h2 id="解题方法">解题方法</h2>
<p>暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法。</p>
<p>找到状态和选择 -&gt; 明确 dp 数组/函数的定义 -&gt; 寻找状态之间的关系。</p>
<h2 id="组合问题划分">组合问题划分</h2>
<h3 id="组合问题公式">组合问题公式</h3>
<p>dp[i] += dp[i-num]</p>
<h3 id="True、False问题公式">True、False问题公式</h3>
<p>dp[i] = dp[i] or dp[i-num]</p>
<h3 id="最大最小问题公式">最大最小问题公式</h3>
<p>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)。</p>
<h2 id="背包问题">背包问题</h2>
<p>背包问题的关注点在于,背包容积的关系,<strong>由前一个背包容积推导到下一个背包的容积的问题</strong>.<br>
注意背包相关问题的典型就是参数是一个整型用于构建动态规划的二维表.<br>
背包问题具备的特征：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。</p>
<h3 id="一般思考的思路">一般思考的思路</h3>
<ul>
<li>
<p>递归求解：由于有大量<strong>重复子问题</strong>，因此必须使用缓存，以避免相同问题重复求解，这个方法叫<strong>记忆化搜索</strong>，在《算法导论》这本书上也把它归入到<strong>动态规划</strong>的定义中。这种思考问题的方式是<strong>从上到下</strong>的，直接面对问题求解，遇到什么问题，就解决什么问题，同时记住结果；</p>
</li>
<li>
<p><strong>动态规划</strong>告诉了我们另一种思考问题的方式：<strong>从底向上</strong>，可以不直接面对问题求解，从这个问题最小的样子开始，通过逐步递推，至到得到所求的问题的答案。</p>
</li>
</ul>
<h3 id="0-1-背包问题">0-1 背包问题</h3>
<p>如果是0-1背包，<strong>即数组中的元素不可重复使用</strong>，nums放在外循环，target在内循环，且内循环倒序；<br>
倒序是为了解决覆盖的问题,不能先求j - nums[i],那么这样的话j-nums[i]已经放入了nums[i]，在之后的求解中会重复利用该元素求解结果，导致结果错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++</span><br><span class="line">    <span class="keyword">for</span> j := target; j &gt;= nums[i - <span class="number">1</span>]; j--</span><br></pre></td></tr></table></figure>
<h3 id="完全背包问题">完全背包问题</h3>
<p>如果是完全背包，<strong>即数组中的元素可重复使用</strong>，nums放在外循环，target在内循环。且内循环正序。<br>
正序是因为本次循环要利用<strong>上个原素的信息</strong>，物品是重复可以使用的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums) </span><br><span class="line">    <span class="keyword">for</span> j := nums[i - <span class="number">1</span>]; j &lt;= target; j++</span><br></pre></td></tr></table></figure>
<h3 id="顺序问题">顺序问题</h3>
<p>如果组合问题需考虑元素之间的顺序，那应该当成排列问题，需将target放在外循环，将nums放在内循环。<br>
原因：</p>
<p>在不考虑物品排列的情况下，我们通常先遍历物品，再遍历背包容量。这是因为对于每个物品，我们都需要在其不放入背包和放入背包两种情况下做选择，而这个选择依赖于背包的剩余容量。所以我们需要先确定物品，再确定背包容量。</p>
<p>在考虑物品排列的情况下，我们通常先遍历背包容量，再遍历物品。这是因为每个物品可以被多次选择，所以我们需要在每种背包容量下，考虑所有的物品。所以我们需要先确定背包容量，再确定物品。</p>
<p><img src="img/algorithm/2024-10-18-09-56-51.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= target; i++</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> nums</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 贪心算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">贪心问题和动态规划不同点是:动态规划最终的最优解是由子问题最优解**推导**过来,子问题的最优解不一定是最终问题的最优解,而贪心算法的最优解是子问题的最优解得出的,在一定程度上可以理解为贪心算法的最优解其实就是在计算子问题的最优解.</span></span><br><span class="line"><span class="string">1、贪心选择性质</span></span><br><span class="line"><span class="string">一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</span></span><br><span class="line"><span class="string">2、最优子结构性质</span></span><br><span class="line"><span class="string">当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心法求解的关键所在。在实际应用中，至于什么问题具有什么样的贪心选择性质是不确定的，需要具体问题具体分析.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 特点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1.不依赖动态规划的表结构.</span></span><br><span class="line"><span class="string">2.不依赖历史决策信息.(历史决策信息不需要保存)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 动态规划和贪心算法的区别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">贪心算法：</span></span><br><span class="line"><span class="string">1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。</span></span><br><span class="line"><span class="string">2.贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。</span></span><br><span class="line"><span class="string">动态规划算法：</span></span><br><span class="line"><span class="string">1.全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解</span></span><br><span class="line"><span class="string">2.动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解</span></span><br><span class="line"><span class="string">3.边界条件：即最简单的，可以直接得出的局部最优解</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 尾递归</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">尾递归是一种在函数return时的递归调用的方式.这样编译器会优化执行,当前的栈是更新的,而不是新增一个栈执行这段代码.因此涉及到尾递归调用的空间复杂度没有正常递归的空间复杂度高,**因此需要注意** .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">非尾部递归,当前栈不能更新,需要保存当前执行状态.</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">function recsum(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + recsum(x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">recsum(5)</span><br><span class="line">5 + recsum(4)</span><br><span class="line">5 + (4 + recsum(3))</span><br><span class="line">5 + (4 + (3 + recsum(2)))</span><br><span class="line">5 + (4 + (3 + (2 + recsum(1))))</span><br><span class="line">5 + (4 + (3 + (2 + 1)))</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>尾递归:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tailrecsum</span>(<span class="params">x, running_total = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> running_total;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">tailrecsum</span>(x - <span class="number">1</span>, running_total + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tailrecsum(5, 0)</span><br><span class="line">tailrecsum(4, 5)</span><br><span class="line">tailrecsum(3, 9)</span><br><span class="line">tailrecsum(2, 12)</span><br><span class="line">tailrecsum(1, 14)</span><br><span class="line">tailrecsum(0, 15)</span><br><span class="line">15</span><br></pre></td></tr></table></figure></div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/liuzexin.github.io/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul></div><div class="post-nav"><a class="pre" href="/liuzexin.github.io/2021/11/20/manacher/">Manacher算法</a><a class="next" href="/liuzexin.github.io/2021/09/17/tcp-nagle/">TCP Nagle 与TCP Delayed ACK性能调研</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://liuzexin.github.io/liuzexin.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpg"/></a><p>Stay foolish, stay hungry.</p><a class="info-icon" href="https://github.com/liuzexin" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://blog.csdn.net/lzx_victory?type=blog" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/liuzexin.github.io/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">线程,进程,协程</a> <a href="/liuzexin.github.io/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/linux-performance/">Linux 性能分析</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/kmp/">KMP算法-php实现</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2022/01/10/go-must-know-key-knowlage/">Go语言必须需要掌握的相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/11/20/manacher/">Manacher算法</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/10/17/algorithm/">算法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/09/17/tcp-nagle/">TCP Nagle 与TCP Delayed ACK性能调研</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/liuzexin.github.io/." rel="nofollow">Eddison.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/liuzexin.github.io/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/liuzexin.github.io/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/liuzexin.github.io/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/liuzexin.github.io/js/smartresize.js?v=1.0.0"></script></div></body></html>