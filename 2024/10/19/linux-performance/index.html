<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Linux 性能分析 | Eddison</title><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/liuzexin.github.io/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/liuzexin.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liuzexin.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liuzexin.github.io/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux 性能分析</h1><a id="logo" href="/liuzexin.github.io/.">Eddison</a><p class="description">欢迎来到这里交流'</p></div><div id="nav-menu"><a class="current" href="/liuzexin.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/liuzexin.github.io/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux 性能分析</h1><div class="post-meta">2024-10-19</div><div class="post-content"><blockquote>
<p>本文基于《Linux性能之巅》以及相关文档,学习笔记整理.<br>
[toc]</p>
</blockquote>
<h2 id="CPU">CPU</h2>
<h3 id="CPU参数介绍">CPU参数介绍</h3>
<ul>
<li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li>
<li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li>
<li>system（通常缩写为 sys），代表内核态 CPU 时间。</li>
<li>idle（通常缩写为 id），代表空闲时间。注意，它<strong>不包括等待 I/O 的时间</strong>（iowait）。</li>
<li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。iowait不一定代表磁盘I/O存在瓶颈，只是代表CPU上I/O操作的时间占用的百分比。假如这时候没有其他进程在运行，那么很小的I/O就会导致iowait升高.</li>
<li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li>
<li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li>
<li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li>
</ul>
<p>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</p>
<p>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</p>
<h3 id="平均负载">平均负载</h3>
<p>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数.</p>
<p><strong>平均负载包括了正在使用CPU的进程，还包括等待CPU和等待I/O的进程</strong></p>
<p>平均活跃进程数=活跃进程数/CPU核心数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span></span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 98.37, 84.48, 77.06</span><br></pre></td></tr></table></figure>
<p>对于48个CPU来讲,1分钟内平均负载98意味着两个进程在抢CPU.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 48.37, 34.48, 47.06</span><br></pre></td></tr></table></figure>
<p>对于48个CPU来讲,1分钟内平均负载48意味着基本1个进程占用CPU.</p>
<p>查看中断类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts</span><br></pre></td></tr></table></figure>
<h3 id="CPU使用率">CPU使用率</h3>
<p>CPU使用率是单位时间内CPU反应繁忙情况的统计.<br>
CPU的使用率一般维持在50%以下,最多不能超过80%.<br>
接近100%使用率,会拖慢整个服务器的性能.</p>
<p>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的.<br>
I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高.</p>
<p>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p>
<p>计算规则:<br>
是时间段内差值计算,时间段内<br>
<img src="en-resource://database/932:1" alt="8408bb45922afb2db09629a9a7eb1d5a.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每隔5秒输出全部CPU相关的统计</span></span><br><span class="line">mpstat -P ALL 5</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每隔5秒输出CPU相关指标</span></span><br><span class="line">pidstat -u 5 1</span><br></pre></td></tr></table></figure>
<p>平均负载高有可能是 CPU 密集型进程导致的.</p>
<p>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了.</p>
<p><code>pstree</code>可以定位进程数,<code>-g</code>可以显示对应的全部进程id和对应的线程.</p>
<p>根据pidstat输出的可以定位到对应的进程,然后在使用<strong>perf</strong>工具对程序进行具体的分析.</p>
<h4 id="CPU上下文切换">CPU上下文切换</h4>
<p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pidstat -wt 5 #每隔5秒显示线程上下文切换的次数 -t显示</span><br><span class="line">Linux 2.6.32_1-18-0-0 (liuzexin) 	08/19/2020 	_x86_64_	(40 CPU)</span><br><span class="line"></span><br><span class="line">04:48:50 PM      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">10:19:58 AM         -     36868      1.00      0.00  |__hhvm</span><br><span class="line">10:19:58 AM         -     37017     33.20      0.00  |__hhvm</span><br><span class="line">10:19:58 AM         -     37018     33.40      0.00  |__hhvm</span><br></pre></td></tr></table></figure>
<p>cswch/s自愿每秒上下文切换的次数,nvcswch/s 非自愿上下文切换次数<br>
自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。<br>
非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa</span><br><span class="line"> 3  0      0 41757720 2284328 66268792    0    0   193   161    0     0 10  3 87  0</span><br><span class="line"> 1  0      0 41751996 2284336 66269068    0    0     0   751 187859 207356  2  4 94  0</span><br></pre></td></tr></table></figure>
<h5 id="系统调用">系统调用</h5>
<p>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。<br>
而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程.</p>
<p>系统调用会产生CPU上下文的切换.系统调用过程通常称为特权模式切换，而不是上下文切换.</p>
<h5 id="进程上下文切换">进程上下文切换</h5>
<p>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<h6 id="进程的状态">进程的状态</h6>
<ul>
<li>
<p>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</p>
</li>
<li>
<p>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</p>
</li>
<li>
<p>Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源(比如进程的描述符、PID 等).大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避免.</p>
</li>
<li>
<p>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。</p>
</li>
<li>
<p>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上.要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</p>
</li>
<li>
<p>T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。</p>
</li>
<li>
<p>X    dead,应该永远不会被看到</p>
</li>
</ul>
<p>也许你会看到一些 ps命令 一些关于运行状态的展示</p>
<ul>
<li>&lt;    高优先级</li>
<li>N    低优先级</li>
<li>L    内存当中含有页锁(实时IO造成)</li>
<li>s    会话组的leader,会话是指共享同一个控制终端的一个或多个进程组.</li>
<li>l    多线程进程</li>
<li>+    表示前台进程组,进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员.</li>
</ul>
<h5 id="线程上下文切换">线程上下文切换</h5>
<p>第一种， 前后两个线程属于不同进程.此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样.</p>
<p>第二种，前后两个线程属于同一个进程.此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据.</p>
<h5 id="中断上下文切换">中断上下文切换</h5>
<p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<h4 id="中断处理">中断处理</h4>
<p>Linux 中的中断处理程序分为上半部和下半部：</p>
<p>上半部对应硬件中断，用来快速处理中断。</p>
<p>下半部对应软中断，用来异步处理上半部未完成的工作。</p>
<p>Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的运行情况。</p>
<h3 id="CPU优化">CPU优化</h3>
<p>第一种，把进程绑定到一个或者多个 CPU 上，充分利用 CPU 缓存的本地性，并减少进程间的相互影响。</p>
<p>第二种，为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。</p>
<p>第三种，使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。</p>
<h3 id="应用程序CPU优化">应用程序CPU优化</h3>
<p><img src="en-resource://database/955:1" alt="238ee65ac4c8e32ef4f96fb0ba8cb0cd.png"></p>
<ul>
<li>编译优化,针对编译语言编译优化编译器提供了很多的选项.</li>
<li>算法优化,这点一般在依赖算法特性比较强的应用,效果显著</li>
<li>异步处理,epoll,kqueue,异步IO等等</li>
<li>协程替代线程,线程替代进程,对于性能并发要求越高的,要选对对应的方式</li>
<li>缓存,缓存在优化方面的意义重大,多数涉及到IO的要留意这点</li>
</ul>
<h3 id="系统优化">系统优化</h3>
<ul>
<li>CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题.</li>
<li>CPU 独占：独占CPU，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程.</li>
<li>优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。</li>
<li>设置资源的使用上限:通过cgroups设置进程的CPU使用上限,防止影响其它租户.</li>
<li>NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存.</li>
<li>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU.开启 irqbalance 服务或者配置 smp_affinity,就可以把中断处理过程自动负载均衡到多个 CPU 上.</li>
</ul>
<h3 id="相关命令">相关命令</h3>
<p><img src="en-resource://database/957:1" alt="9a211905538faffb5b3221ee01776a69.png"></p>
<p><img src="evernotecid://8BF4008B-52C0-484E-A4B5-8EBD45F20215/appyinxiangcom/13973009/ENNote/p293?hash=28cb85011289f83804c51c1fb275dab0" alt="28cb85011289f83804c51c1fb275dab0.png"></p>
<h2 id="内存">内存</h2>
<h3 id="基础概念">基础概念</h3>
<p>虚拟内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算作虚拟内存。</p>
<p>常驻内存是进程实际使用的物理内存，不过，它不包括 Swap 和共享内存。</p>
<p>共享内存，既包括与其他进程共同使用的真实的共享内存，还包括了加载的动态链接库以及程序的代码段等。</p>
<p>Swap 内存，是指通过 Swap 换出到磁盘的内存。</p>
<p>在内核空间，Linux 则通过 slab 分配器来管理小内存。你可以把 slab 看成构建在伙伴系统上的一个缓存，主要作用就是分配并释放内核中的小对象。malloc本身不会使用slab,只有内核中使用kmalloc才回通过slab分配内存.</p>
<h4 id="内存映射">内存映射</h4>
<p>虚拟地址空间的内部又被分为内核空间和用户空间两部分.<br>
内存映射虚拟内存地址映射到物理内存地址.</p>
<p>TLB 其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多.</p>
<p><img src="en-resource://database/933:1" alt="fcfbe2f8eb7c6090d82bf93ecdc1f0b6.png"></p>
<p>MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB 整数倍的内存空间.</p>
<p>页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大。比方说，仅 32 位系统就需要 100 多万个页表项（4GB/4KB），才可以实现整个地址空间的映射。为了解决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）.</p>
<p>多级页表就是把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移.<br>
Linux 用的正是四级页表来管理内存页，如下图所示，虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移<br>
<img src="en-resource://database/934:1" alt="b5c9179ac64eb5c7ca26448065728325.png"></p>
<h4 id="内存分配">内存分配</h4>
<p>进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行.</p>
<blockquote>
<p>可以直接从物理内存中分配时，被称为次缺页异常.<br>
需要磁盘 I/O 介入（比如 Swap）时，被称为主缺页异常.</p>
</blockquote>
<p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p>
<ul>
<li>
<p>小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。</p>
</li>
<li>
<p>大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去.而 mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的</p>
</li>
<li>
<p>内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap 的原因</p>
</li>
</ul>
<h5 id="内存超出分配解决">内存超出分配解决</h5>
<p>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；<br>
回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中,Swap 其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中.<br>
杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。OOM（Out of Memory），其实是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：一个进程消耗的内存越大，oom_score 就越大,一个进程运行占用的 CPU 越多oom_score 就越小。管理员可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。<br>
oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM.</p>
<h4 id="虚拟内存空间分布">虚拟内存空间分布</h4>
<p>首先，我们需要进一步了解虚拟内存空间的分布情况。最上方的内核空间不用多讲，下方的用户空间内存，其实又被分成了多个不同的段.</p>
<p><img src="en-resource://database/935:1" alt="71a754523386cc75f4456a5eabc93c5d.png"></p>
<ul>
<li>只读段，包括代码和常量等。</li>
<li>数据段，包括全局变量等。</li>
<li>堆，包括动态分配的内存，从低地址开始向上增长。</li>
<li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长。</li>
<li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。<br>
使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存.</li>
</ul>
<h4 id="cache与buffer">cache与buffer</h4>
<p>简单来说，Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中.</p>
<ul>
<li>Buffer 既可以用作“将要写入磁盘数据的缓存”，也可以用作“从磁盘读取数据的缓存”。</li>
<li>Cache 既可以用作“从文件读取数据的页缓存”，也可以用作“写文件的页缓存”。</li>
</ul>
<blockquote>
<p>Buffers are associated with a specific block device, and cover caching of filesystem metadata as well as tracking in-flight pages. The cache only contains parked file data. That is, the buffers remember what’s in directories, what file permissions are, and keep track of what memory is being written from or read to for a particular block device. The cache only contains the contents of the files themselves.</p>
</blockquote>
<p>理论上，一个文件读首先到Block Buffer, 然后到Page Cache。有了文件系统才有了Page Cache.<br>
在老的Linux上这两个Cache是分开的。那这样对于文件数据，会被Cache两次。这种方案虽然简单,但低效。后期Linux把这两个Cache统一了。对于文件，Page Cache指向Block Buffer，对于非文件则是Block Buffer。这样就如文件实验的结果，文件操作，只影响Page Cache，Raw操作，则只影响Buffer. 比如一此VM虚拟机，则会越过File System，直接操作 Disk, 常说的Direct IO.</p>
<h4 id="swap原理">swap原理</h4>
<p>Swap 把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用.<br>
对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收.</p>
<p>而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存.</p>
<h5 id="换入与换出">换入与换出</h5>
<p>所谓换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。</p>
<p>而换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</p>
<h5 id="直接回收内存和定期回收内存">直接回收内存和定期回收内存</h5>
<p>直接回收内存:有新的大块内存分配请求，但是剩余内存不足。这个时候系统就需要回收一部分内存，进而尽可能地满足新内存请求。这个过程通常被称为直接内存回收.<br>
定期回收内存:kswapd0专门的线程定期扫描内存的使用情况,并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作.</p>
<p><img src="en-resource://database/936:1" alt="c1054f1e71037795c6f290e670b29120.png"></p>
<p>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。</p>
<p>剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。</p>
<p>剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。</p>
<p>剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。<br>
页低阈值:内核选项 /proc/sys/vm/min_free_kbytes 来间接设置.<br>
其它两个阀值:<br>
<code>pages_low = pages_min*5/4</code><br>
<code>pages_high = pages_min*3/2</code></p>
<h5 id="NUMA-与swap">NUMA 与swap</h5>
<p>在 NUMA架构下,多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间.<br>
<img src="en-resource://database/937:1" alt="be6cabdecc2ec98893f67ebd5b9aead9.png"></p>
<p>查看命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/zoneinfo</span></span><br><span class="line">...</span><br><span class="line">Node 0, zone   Normal</span><br><span class="line"> pages free     227894</span><br><span class="line">       min      14896</span><br><span class="line">       low      18620</span><br><span class="line">       high     22344</span><br><span class="line">...</span><br><span class="line">     nr_free_pages 227894</span><br><span class="line">     nr_zone_inactive_anon 11082</span><br><span class="line">     nr_zone_active_anon 14024</span><br><span class="line">     nr_zone_inactive_file 539024</span><br><span class="line">     nr_zone_active_file 923986</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>pages 处的 min、low、high，就是上面提到的三个内存阈值，而 free 是剩余内存页数，它跟后面的 nr_free_pages 相同。</p>
<p>nr_zone_active_anon 和 nr_zone_inactive_anon，分别是活跃和非活跃的匿名页数。</p>
<p>nr_zone_active_file 和 nr_zone_inactive_file，分别是活跃和非活跃的文件页数。</p>
<p>/proc/sys/vm/zone_reclaim_mode:<br>
默认的 0 ，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地回收内存。</p>
<p>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据回收内存，4 表示可以用 Swap 方式回收内存。</p>
<p>/proc/sys/vm/swappiness 选项，用来调整使用 Swap 的积极程度。</p>
<p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p>
<h4 id="swap解决方案">swap解决方案</h4>
<p>在高性能场景的要求下,机械磁盘尽量不要使用swap,这会导致严重的性能问题.</p>
<ul>
<li>
<p>禁止 Swap，现在服务器的内存足够大，所以除非有必要，禁用 Swap 就可以了。随着云计算的普及，大部分云平台中的虚拟机都默认禁止 Swap。</p>
</li>
<li>
<p>如果实在需要用到 Swap，可以尝试降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。</p>
</li>
<li>
<p>响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以用库函数 mlock() 或者 mlockall() 锁定内存，阻止它们的内存换出。</p>
</li>
</ul>
<h3 id="内存优化">内存优化</h3>
<p>第一种，除非有必要，Swap 应该禁止掉。这样就可以避免 Swap 的额外 I/O ，带来内存访问变慢的问题。</p>
<p>第二种，使用 Cgroups 等方法，为进程设置内存限制。这样就可以避免个别进程消耗过多内存，而影响了其他进程。对于核心应用，还应该降低 oom_score，避免被 OOM 杀死。</p>
<p>第三种，使用大页、内存池等方法，减少内存的动态分配，从而减少缺页异常。</p>
<h3 id="相关命令-2">相关命令</h3>
<p><img src="en-resource://database/958:1" alt="ee36f73b9213063b3bcdaed2245944c0.png"></p>
<p><img src="en-resource://database/956:1" alt="292d64ac6bce0fe6a7a6b4250f34e998.png"></p>
<p><img src="en-resource://database/960:1" alt="79ad5caf0a2c105b7e9ce77877d493f8.png"></p>
<h4 id="dmseg">dmseg</h4>
<p>输出内核消息到标准输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep -i &quot;Out of memory&quot;</span><br><span class="line">Out of memory: Kill process 9329 (java) score 321 or sacrifice child</span><br></pre></td></tr></table></figure>
<h4 id="free-命令">free 命令</h4>
<p>第一列，total 是总内存大小；</p>
<p>第二列，used 是已使用内存的大小，包含了共享内存；</p>
<p>第三列，free 是未使用内存的大小；</p>
<p>第四列，shared 是共享内存的大小；</p>
<p>第五列，buff/cache 是缓存和缓冲区的大小；free 输出的 Cache，是 /proc/meminfo页缓存和可回收 Slab 缓存的和<code>cat /proc/meminfo | grep -E &quot;SReclaimable|Cached&quot;</code>.</p>
<p>最后一列，available 是新进程可用内存的大小。available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。 有的版本不支持展示这一列,通过<code>cat /proc/meminfo</code>的MemAvailable得到该值.</p>
<h4 id="top-命令">top 命令</h4>
<p>-VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</p>
<ul>
<li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li>
<li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li>
<li>%MEM 是进程使用物理内存占系统总内存的百分比。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">2114 root      39  19  769m  75m  11m S  2.3  0.5   1958:36 baas_agent</span><br></pre></td></tr></table></figure>
<h4 id="cachestat-bctools">cachestat-bctools</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cachestat 1 3</span><br><span class="line">   TOTAL   MISSES     HITS  DIRTIES   BUFFERS_MB  CACHED_MB</span><br><span class="line">       2        0        2        1           17        279</span><br><span class="line">       2        0        2        1           17        279</span><br><span class="line">       2        0        2        1           17        279 </span><br></pre></td></tr></table></figure>
<p>cachestat 的输出其实是一个表格。每行代表一组数据，而每一列代表不同的缓存统计指标。这些指标从左到右依次表示：</p>
<p>TOTAL ，表示总的 I/O 次数；</p>
<p>MISSES ，表示缓存未命中的次数；</p>
<p>HITS ，表示缓存命中的次数,命中次数,每次命中的大小为4KB</p>
<p>DIRTIES， 表示新增到缓存中的脏页数；</p>
<p>BUFFERS_MB 表示 Buffers 的大小，以 MB 为单位；<br>
CACHED_MB 表示 Cache 的大小，以 MB 为单位。</p>
<h4 id="cachetop-bctools">cachetop-bctools</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cachetop</span><br><span class="line">11:58:50 Buffers MB: 258 / Cached MB: 347 / Sort: HITS / Order: ascending</span><br><span class="line">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%</span><br><span class="line">   13029 root     python                  1        0        0     100.0%       0.0%</span><br></pre></td></tr></table></figure>
<p>READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率.</p>
<h4 id="memleak-bctools">memleak-bctools</h4>
<p>检测内存泄露的工具.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/share/bcc/tools/memleak -p $(pidof app) -a</span><br><span class="line">Attaching to pid 12512, Ctrl+C to quit.</span><br><span class="line">[03:00:41] Top 10 stacks with outstanding allocations:</span><br><span class="line">    addr = 7f8f70863220 size = 8192</span><br><span class="line">    addr = 7f8f70861210 size = 8192</span><br><span class="line">    addr = 7f8f7085b1e0 size = 8192</span><br><span class="line">    addr = 7f8f7085f200 size = 8192</span><br><span class="line">    addr = 7f8f7085d1f0 size = 8192</span><br><span class="line">    40960 bytes in 5 allocations from stack</span><br><span class="line">        fibonacci+0x1f [app]</span><br><span class="line">        child+0x4f [app]</span><br><span class="line">        start_thread+0xdb [libpthread-2.27.so] </span><br></pre></td></tr></table></figure>
<h4 id="valgrind">valgrind</h4>
<p>valgrind 是一个功能比较丰富的工具,支持的功能很多.当然也可以被用于内存泄露的分析.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=yes --show-reachable=yes --num-callers=20 --track-fds=yes ./test</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">==9704== Memcheck, a memory error detector for x86-linux.</span><br><span class="line">==9704== Copyright (C) 2002-2004, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==9704== Using valgrind-2.2.0, a program supervision framework for x86-linux.</span><br><span class="line">==9704== Copyright (C) 2000-2004, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==9704== For more details, rerun with: -v</span><br><span class="line">==9704== </span><br><span class="line">==9704== </span><br><span class="line">==9704== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 11 from 1)</span><br><span class="line">==9704== malloc/free: in use at exit: 35 bytes in 2 blocks.</span><br><span class="line">==9704== malloc/free: 3 allocs, 1 frees, 47 bytes allocated.</span><br><span class="line">==9704== For counts of detected errors, rerun with: -v</span><br><span class="line">==9704== searching for pointers to 2 not-freed blocks.</span><br><span class="line">==9704== checked 1420940 bytes.</span><br><span class="line">==9704== </span><br><span class="line">==9704== 16 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==9704==    at 0x1B903D38: malloc (vg_replace_malloc.c:131)</span><br><span class="line">==9704==    by 0x80483BF: main (test.c:15)</span><br><span class="line">==9704== </span><br><span class="line">==9704== </span><br><span class="line">==9704== 19 bytes in 1 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==9704==    at 0x1B903D38: malloc (vg_replace_malloc.c:131)</span><br><span class="line">==9704==    by 0x8048391: main (test.c:8)</span><br><span class="line">==9704== </span><br><span class="line">==9704== LEAK SUMMARY:</span><br><span class="line">==9704==    definitely lost: 35 bytes in 2 blocks.</span><br><span class="line">==9704==    possibly lost:   0 bytes in 0 blocks.</span><br><span class="line">==9704==    still reachable: 0 bytes in 0 blocks.</span><br><span class="line">==9704==         suppressed: 0 bytes in 0 blocks.</span><br></pre></td></tr></table></figure>
<h2 id="IO">IO</h2>
<p><img src="en-resource://database/938:1" alt="328d942a38230a973f11bae67307be47.png"></p>
<h3 id="基本概念">基本概念</h3>
<p><img src="en-resource://database/939:1" alt="728b7b39252a1e23a7a223cdf4aa1612.png"></p>
<h4 id="文件的基本数据结构">文件的基本数据结构</h4>
<p>Linux的文件由两个数据结构组成</p>
<p>索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</p>
<p>目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</p>
<h4 id="存储区域的划分">存储区域的划分</h4>
<p>超级块，存储整个文件系统的状态。<br>
索引节点区，用来存储索引节点。<br>
数据块区，则用来存储文件数据。</p>
<h4 id="VFS-通用设备块">VFS&amp;通用设备块</h4>
<p>Linux的虚拟文件系统是基于实际的文件系统的抽象.为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。</p>
<p>通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能 。</p>
<p>第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。</p>
<p>第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</p>
<p><img src="en-resource://database/940:1" alt="14bc3d26efe093d3eada173f869146b1.png"></p>
<h4 id="IO类型">IO类型</h4>
<p>之前讲过IO的类型分为阻塞非阻塞,异步和非异步的区别.<br>
这里在讲下另一种区别的IO:</p>
<ul>
<li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。O_DIRECT 标志.</li>
<li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li>
</ul>
<h3 id="基准测试">基准测试</h3>
<p>fio</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 随机读</span><br><span class="line">fio -name=randread -direct=1 -iodepth=64 -rw=randread -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb</span><br><span class="line"> </span><br><span class="line"># 随机写</span><br><span class="line">fio -name=randwrite -direct=1 -iodepth=64 -rw=randwrite -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb</span><br><span class="line"> </span><br><span class="line"># 顺序读</span><br><span class="line">fio -name=read -direct=1 -iodepth=64 -rw=read -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb</span><br><span class="line"> </span><br><span class="line"># 顺序写</span><br><span class="line">fio -name=write -direct=1 -iodepth=64 -rw=write -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb </span><br></pre></td></tr></table></figure>
<p>direct，表示是否跳过系统缓存。上面示例中，我设置的 1 ，就表示跳过系统缓存。</p>
<p>iodepth，表示使用异步 I/O（asynchronous I/O，简称 AIO）时，同时发出的 I/O 请求上限。在上面的示例中，我设置的是 64。</p>
<p>rw，表示 I/O 模式。我的示例中， read/write 分别表示顺序读 / 写，而 randread/randwrite 则分别表示随机读 / 写。</p>
<p>ioengine，表示 I/O 引擎，它支持同步（sync）、异步（libaio）、内存映射（mmap）、网络（net）等各种 I/O 引擎。上面示例中，我设置的 libaio 表示使用异步 I/O。</p>
<p>bs，表示 I/O 的大小。示例中，我设置成了 4K（这也是默认值）。</p>
<p>filename，表示文件路径，当然，它可以是磁盘路径（测试磁盘性能），也可以是文件路径（测试文件系统性能）。示例中，我把它设置成了磁盘 /dev/sdb。不过注意，<strong>用磁盘路径测试写，会破坏这个磁盘中的文件系统，所以在使用前，你一定要事先做好数据备份</strong>。</p>
<h3 id="磁盘IO以及相关指标">磁盘IO以及相关指标</h3>
<p><img src="en-resource://database/942:1" alt="b6d67150e471e1340a6f3c3dc3ba0120.png"></p>
<p>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。<br>
饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。<br>
IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。<br>
吞吐量，是指每秒的 I/O 请求大小。<br>
响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</p>
<h3 id="相关命令-3">相关命令</h3>
<p><img src="en-resource://database/943:1" alt="1802a35475ee2755fb45aec55ed2d98a.png"></p>
<p><img src="en-resource://database/959:1" alt="c232dcb4185f7b7ba95c126889cf6fa3.png"></p>
<h4 id="slabinfo">slabinfo</h4>
<p>/proc/meminfo 只给出了 Slab 的整体大小，具体到每一种 Slab 缓存.下面的输出，dentry 行表示目录项缓存，inode_cache 行，表示 VFS 索引节点缓存，其余的则是各种文件系统的索引节点缓存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/slabinfo | grep -E <span class="string">&#x27;^#|dentry|inode&#x27;</span> </span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt; </span></span><br><span class="line">xfs_inode              0      0    960   17    4 : tunables    0    0    0 : slabdata      0      0      0 </span><br><span class="line">... </span><br><span class="line">ext4_inode_cache   32104  34590   1088   15    4 : tunables    0    0    0 : slabdata   2306   2306      0hugetlbfs_inode_cache     13     13    624   13    2 : tunables    0    0    0 : slabdata      1      1      0 </span><br><span class="line">sock_inode_cache    1190   1242    704   23    4 : tunables    0    0    0 : slabdata     54     54      0 </span><br><span class="line">shmem_inode_cache   1622   2139    712   23    4 : tunables    0    0    0 : slabdata     93     93      0 </span><br><span class="line">proc_inode_cache    3560   4080    680   12    2 : tunables    0    0    0 : slabdata    340    340      0 </span><br><span class="line">inode_cache        25172  25818    608   13    2 : tunables    0    0    0 : slabdata   1986   1986      0 </span><br><span class="line">dentry             76050 121296    192   21    1 : tunables    0    0    0 : slabdata   5776   5776      0 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="iostat">iostat</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> #-d -x 表示显示所有磁盘 I/O 的指标</span><br><span class="line">$ iostat -d -x 1 </span><br><span class="line">Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util </span><br><span class="line">loop0            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 </span><br><span class="line">loop1            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 </span><br><span class="line">sda              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 </span><br><span class="line">sdb              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 </span><br></pre></td></tr></table></figure>
<p><img src="en-resource://database/941:1" alt="cff31e715af51c9cb8085ce1bb48318d.png"></p>
<h4 id="pidstat">pidstat</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -d 1 </span><br><span class="line">13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command </span><br><span class="line">13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd</span><br></pre></td></tr></table></figure>
<p>用户 ID（UID）和进程 ID（PID） 。</p>
<p>每秒读取的数据大小（kB_rd/s） ，单位是 KB。</p>
<p>每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。</p>
<p>每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。</p>
<p>块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</p>
<h4 id="iotop">iotop</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ iotop</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s </span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s </span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND </span><br><span class="line">15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald</span><br></pre></td></tr></table></figure>
<h4 id="lsof">lsof</h4>
<p>lsof查看进程打开文件的情况.<br>
SIZE：文件的大小<br>
NODE：索引节点（文件在磁盘上的标识）<br>
NAME：打开文件的确切名称<br>
FD:<br>
cwd current working directory<br>
rtd root directory<br>
txt program text (code and data)<br>
mem memory-mapped file<br>
<code>1u</code> 1是真实的文件描述符 跟随的文件打开的模式.<br>
r for read access.<br>
w for write access.<br>
u for read and write access.</p>
<p>TPPE 文件类型:<br>
DIR – Directory<br>
REG – Regular file<br>
CHR – Character special file.<br>
FIFO – First In First Ou</p>
<p><strong>重要用途</strong></p>
<p>1.查看用户打开的文件.<br>
2.查看进程打开的文件,端口<br>
3.查看进程支持的IP协议<br>
4.列出所有 嗲还哦链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> lsof -p 50216</span><br><span class="line">COMMAND    PID     USER   FD      TYPE             DEVICE   SIZE/OFF    NODE NAME</span><br><span class="line">Evernote 50216 liuzexin  cwd       DIR                1,4        960       2 /</span><br><span class="line">Evernote 50216 liuzexin  txt       REG                1,4   19534848 5975494 /Applications/印象笔记.app/Contents/S/Evernote</span><br></pre></td></tr></table></figure>
<h3 id="优化思路">优化思路</h3>
<h4 id="应用程序优化">应用程序优化</h4>
<p>首先，我们来看一下，从应用程序的角度有哪些优化 I/O 的思路。</p>
<p>应用程序处于整个 I/O 栈的最上端，它可以通过系统调用，来调整 I/O 模式（如顺序还是随机、同步还是异步）， 同时，它也是 I/O 数据的最终来源。在我看来，可以有这么几种方式来优化应用程序的 I/O 性能。</p>
<p><strong>第一，可以用追加写代替随机写，减少寻址开销，加快 I/O 写的速度。</strong></p>
<p><strong>第二，可以借助缓存 I/O ，充分利用系统缓存，降低实际 I/O 的次数。</strong></p>
<p>第三，可以在应用程序内部构建自己的缓存，或者用 Redis 这类外部缓存系统。这样，一方面，能在应用程序内部，控制缓存的数据和生命周期；另一方面，也能降低其他应用程序使用缓存对自身的影响。</p>
<p>比如，在前面的 MySQL 案例中，我们已经见识过，只是因为一个干扰应用清理了系统缓存，就会导致 MySQL 查询有数百倍的性能差距（0.1s vs 15s）。</p>
<p>再如， C 标准库提供的 fopen、fread 等库函数，都会利用标准库的缓存，减少磁盘的操作。而你直接使用 open、read 等系统调用时，就只能利用操作系统提供的页缓存和缓冲区等，而没有库函数的缓存可用。</p>
<p>第四，在需要频繁读写同一块磁盘空间时，可以用 mmap 代替 read/write，减少内存的拷贝次数。</p>
<p><strong>第五，在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC。</strong></p>
<p>第六，在多个应用程序共享相同磁盘时，为了保证 I/O 不被某个应用完全占用，推荐你使用 cgroups 的 I/O 子系统，来限制进程 / 进程组的 IOPS 以及吞吐量。</p>
<p>最后，在使用 CFQ 调度器时，可以用 ionice 来调整进程的 I/O 调度优先级，特别是提高核心应用的 I/O 优先级。ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</p>
<h4 id="文件系统优化">文件系统优化</h4>
<p>应用程序访问普通文件时，实际是由文件系统间接负责，文件在磁盘中的读写。所以，跟文件系统中相关的也有很多优化 I/O 性能的方式。</p>
<p>第一，你可以根据实际负载场景的不同，选择最适合的文件系统。比如 Ubuntu 默认使用 ext4 文件系统，而 CentOS 7 默认使用 xfs 文件系统。</p>
<p>相比于 ext4 ，xfs 支持更大的磁盘分区和更大的文件数量，如 xfs 支持大于 16TB 的磁盘。但是 xfs 文件系统的缺点在于无法收缩，而 ext4 则可以。</p>
<p><strong>第二，在选好文件系统后，还可以进一步优化文件系统的配置选项，包括文件系统的特性（如 ext_attr、dir_index）、日志模式（如 journal、ordered、writeback）、挂载选项（如 noatime）等等。</strong></p>
<p>比如， 使用 tune2fs 这个工具，可以调整文件系统的特性（tune2fs 也常用来查看文件系统超级块的内容）。 而通过 /etc/fstab ，或者 mount 命令行参数，我们可以调整文件系统的日志模式和挂载选项等。</p>
<p><strong>第三，可以优化文件系统的缓存。</strong></p>
<p><strong>比如，你可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。</strong></p>
<p>再如，你还可以优化内核回收目录项缓存和索引节点缓存的倾向，即调整 vfs_cache_pressure（/proc/sys/vm/vfs_cache_pressure，默认值 100），数值越大，就表示越容易回收。</p>
<p>最后，在不需要持久化时，你还可以用内存文件系统 tmpfs，以获得更好的 I/O 性能 。tmpfs 把数据直接保存在内存中，而不是磁盘中。比如 /dev/shm/ ，就是大多数 Linux 默认配置的一个内存文件系统，它的大小默认为总内存的一半。</p>
<h4 id="磁盘优化">磁盘优化</h4>
<p>数据的持久化存储，最终还是要落到具体的物理磁盘中，同时，磁盘也是整个 I/O 栈的最底层。从磁盘角度出发，自然也有很多有效的性能优化方法。</p>
<p>第一，最简单有效的优化方法，就是换用性能更好的磁盘，比如用 SSD 替代 HDD。</p>
<p><strong>第二，我们可以使用 RAID ，把多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列。这样做既可以提高数据的可靠性，又可以提升数据的访问性能。</strong></p>
<p>第三，针对磁盘和应用程序 I/O 模式的特征，我们可以选择最适合的 I/O 调度算法。比方说，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法。而数据库应用，我更推荐使用 deadline 算法。</p>
<p><strong>第四，我们可以对应用程序的数据，进行磁盘级别的隔离。比如，我们可以为日志、数据库等 I/O 压力比较重的应用，配置单独的磁盘。</strong></p>
<p>第五，在顺序读比较多的场景中，我们可以增大磁盘的预读数据，比如，你可以通过下面两种方法，调整 /dev/sdb 的预读大小。</p>
<p>调整内核选项 /sys/block/sdb/queue/read_ahead_kb，默认大小是 128 KB，单位为 KB。</p>
<p>使用 blockdev 工具设置，比如 blockdev --setra 8192 /dev/sdb，注意这里的单位是 512B（0.5KB），所以它的数值总是 read_ahead_kb 的两倍。</p>
<p>第六，我们可以优化内核块设备 I/O 的选项。比如，可以调整磁盘队列的长度 /sys/block/sdb/queue/nr_requests，适当增大队列长度，可以提升磁盘的吞吐量（当然也会导致 I/O 延迟增大）。</p>
<p>最后，要注意，磁盘本身出现硬件错误，也会导致 I/O 性能急剧下降，所以发现磁盘性能急剧下降时，你还需要确认，磁盘本身是不是出现了硬件错误。</p>
<p>比如，你可以查看 dmesg 中是否有硬件 I/O 故障的日志。 还可以使用 badblocks、smartctl 等工具，检测磁盘的硬件问题，或用 e2fsck 等来检测文件系统的错误。如果发现问题，你可以使用 fsck 等工具来修复。</p>
<h3 id="磁盘文件系统的优化">磁盘文件系统的优化</h3>
<p>第一种，也是最简单的方法，通过 SSD 替代 HDD、或者使用 RAID 等方法，提升 I/O 性能。</p>
<p>第二种，针对磁盘和应用程序 I/O 模式的特征，选择最适合的 I/O 调度算法。比如，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法；而数据库应用，更推荐使用 deadline 算法。</p>
<p>第三，优化文件系统和磁盘的缓存、缓冲区，比如优化脏页的刷新频率、脏页限额，以及内核回收目录项缓存和索引节点缓存的倾向等等。</p>
<h2 id="网络">网络</h2>
<h3 id="性能指标">性能指标</h3>
<p>带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。</p>
<p>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。</p>
<p>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</p>
<p>PPS，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。</p>
<h3 id="优化措施">优化措施</h3>
<p>1.IO网络模型的优化,面对高并发的客户端请求,一般建议是epoll的网络模型下非惊群方式,<br>
2.工作模型优化:主进程 + 多个 worker 子进程，这也是最常用的一种模型</p>
<ul>
<li>主进程执行 bind() + listen() 后，创建多个子进程；</li>
<li>然后，在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字<br>
监听到相同端口的多进程模型,所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去,这种模式不常用。<br>
<img src="en-resource://database/944:1" alt="90df0945f6ce5c910ae361bf2b135bbd.png"><br>
3.Linux网络深层处理优化,这种方式思路避免Linux的内核在网络请求的处理时不停的切换内核态和用户态,通过绕开Linux的网络协议的处理直接将网络包交给应用程序处理.<br>
第一种机制，DPDK，是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。<br>
<img src="en-resource://database/945:1" alt="998fd2f52f0a48a910517ada9f2bb23a.png"></li>
</ul>
<p>第二种机制，XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。XDP 底层跟我们之前用到的 bcc-tools 一样，都是基于 Linux 内核的 eBPF 机制实现的。<br>
<img src="en-resource://database/946:1" alt="067ef9df4212cd4ede3cffcdac7001be.png"></p>
<h3 id="tcp-优化">tcp 优化</h3>
<p>第一类，在请求数比较大的场景下，你可能会看到大量处于 TIME_WAIT 状态的连接，它们会占用大量内存和端口资源。这时，我们可以优化与 TIME_WAIT 状态相关的内核选项，比如采取下面几种措施。</p>
<ul>
<li>增大处于 TIME_WAIT 状态的连接数量 net.ipv4.tcp_max_tw_buckets ，并增大连接跟踪表的大小 net.netfilter.nf_conntrack_max。</li>
<li>减小 net.ipv4.tcp_fin_timeout 和 net.netfilter.nf_conntrack_tcp_timeout_time_wait ，让系统尽快释放它们所占用的资源。</li>
<li>开启端口复用 net.ipv4.tcp_tw_reuse。这样，被 TIME_WAIT 状态占用的端口，还能用到新建的连接中。</li>
<li>增大本地端口的范围 net.ipv4.ip_local_port_range 。这样就可以支持更多连接，提高整体的并发能力。</li>
<li>增加最大文件描述符的数量。你可以使用 fs.nr_open 和 fs.file-max ，分别增大进程和系统的最大文件描述符数；或在应用程序的 systemd 配置文件中，配置 LimitNOFILE ，设置应用程序的最大文件描述符数。</li>
</ul>
<p>第二类，为了缓解 SYN FLOOD 等，利用 TCP 协议特点进行攻击而引发的性能问题，你可以考虑优化与 SYN 状态相关的内核选项，比如采取下面几种措施。</p>
<ul>
<li>增大 TCP 半连接的最大数量 net.ipv4.tcp_max_syn_backlog ，或者开启 TCP SYN Cookies net.ipv4.tcp_syncookies ，来绕开半连接数量限制的问题（注意，这两个选项不可同时使用）。</li>
<li>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 net.ipv4.tcp_synack_retries。</li>
</ul>
<p>第三类，在长连接的场景中，通常使用 Keepalive 来检测 TCP 连接的状态，以便对端连接断开后，可以自动回收。但是，系统默认的 Keepalive 探测间隔和重试次数，一般都无法满足应用程序的性能要求。所以，这时候你需要优化与 Keepalive 相关的内核选项，比如：</p>
<ul>
<li>缩短最后一次数据包到 Keepalive 探测包的间隔时间 net.ipv4.tcp_keepalive_time；</li>
<li>缩短发送 Keepalive 探测包的间隔时间 net.ipv4.tcp_keepalive_intvl；</li>
<li>减少 Keepalive 探测失败后，一直到通知应用程序前的重试次数 net.ipv4.tcp_keepalive_probes。</li>
</ul>
<h3 id="网络层优化">网络层优化</h3>
<p>第一种，从路由和转发的角度出发，你可以调整下面的内核选项。</p>
<ul>
<li>
<p>在需要转发的服务器中，比如用作 NAT 网关的服务器或者使用 Docker 容器时，开启 IP 转发，即设置 net.ipv4.ip_forward = 1。</p>
</li>
<li>
<p>调整数据包的生存周期 TTL，比如设置 net.ipv4.ip_default_ttl = 64。注意，增大该值会降低系统性能。</p>
</li>
<li>
<p>开启数据包的反向地址校验，比如设置 net.ipv4.conf.eth0.rp_filter = 1。这样可以防止 IP 欺骗，并减少伪造 IP 带来的 DDoS 问题。<br>
第二种，从分片的角度出发，最主要的是调整 MTU（Maximum Transmission Unit）的大小。</p>
</li>
<li>
<p>通常，MTU 的大小应该根据以太网的标准来设置。以太网标准规定，一个网络帧最大为 1518B，那么去掉以太网头部的 18B 后，剩余的 1500 就是以太网 MTU 的大小。</p>
</li>
<li>
<p>另外，现在很多网络设备都支持巨帧，如果是这种环境，你还可以把 MTU 调大为 9000，以提高网络吞吐量。<br>
第三种，从 ICMP 的角度出发，为了避免 ICMP 主机探测、ICMP Flood 等各种网络问题，你可以通过内核选项，来限制 ICMP 的行为。</p>
</li>
<li>
<p>比如，你可以禁止 ICMP 协议，即设置 net.ipv4.icmp_echo_ignore_all = 1。这样，外部主机就无法通过 ICMP 来探测主机。</p>
</li>
<li>
<p>或者，你还可以禁止广播 ICMP，即设置 net.ipv4.icmp_echo_ignore_broadcasts = 1。</p>
</li>
</ul>
<h3 id="链路层优化">链路层优化</h3>
<p>软中断优化</p>
<ul>
<li>比如，你可以为网卡硬中断配置 CPU 亲和性（smp_affinity），或者开启 irqbalance 服务。</li>
<li>再如，你可以开启 RPS（Receive Packet Steering）和 RFS（Receive Flow Steering），将应用程序和软中断的处理，调度到相同 CPU 上，这样就可以增加 CPU 缓存命中率，减少网络延迟。</li>
</ul>
<p>现在的网卡都有很丰富的功能，原来在内核中通过软件处理的功能，可以卸载到网卡中，通过硬件来执行</p>
<ul>
<li>
<p>TSO（TCP Segmentation Offload）和 UFO（UDP Fragmentation Offload）：在 TCP/UDP 协议中直接发送大包；而 TCP 包的分段（按照 MSS 分段）和 UDP 的分片（按照 MTU 分片）功能，由网卡来完成 。</p>
</li>
<li>
<p>GSO（Generic Segmentation Offload）：在网卡不支持 TSO/UFO 时，将 TCP/UDP 包的分段，延迟到进入网卡前再执行。这样，不仅可以减少 CPU 的消耗，还可以在发生丢包时只重传分段后的包。</p>
</li>
<li>
<p>LRO（Large Receive Offload）：在接收 TCP 分段包时，由网卡将其组装合并后，再交给上层网络处理。不过要注意，在需要 IP 转发的情况下，不能开启 LRO，因为如果多个包的头部信息不一致，LRO 合并会导致网络包的校验错误。</p>
</li>
<li>
<p>GRO（Generic Receive Offload）：GRO 修复了 LRO 的缺陷，并且更为通用，同时支持 TCP 和 UDP。</p>
</li>
<li>
<p>RSS（Receive Side Scaling）：也称为多队列接收，它基于硬件的多个接收队列，来分配网络接收进程，这样可以让多个 CPU 来处理接收到的网络包。</p>
</li>
<li>
<p>VXLAN 卸载：也就是让网卡来完成 VXLAN 的组包功能。</p>
</li>
</ul>
<p>网络接口优化</p>
<ul>
<li>比如，你可以开启网络接口的多队列功能。这样，每个队列就可以用不同的中断号，调度到不同 CPU 上执行，从而提升网络的吞吐量。</li>
<li>再如，你可以增大网络接口的缓冲区大小，以及队列长度等，提升网络传输的吞吐量（注意，这可能导致延迟增大）。</li>
<li>你还可以使用 Traffic Control 工具，为不同网络流量配置 QoS。</li>
</ul>
<p>内核协议处理优化</p>
<ul>
<li>
<p>第一种，使用 DPDK 技术，跳过内核协议栈，直接由用户态进程用轮询的方式，来处理网络请求。同时，再结合大页、CPU 绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</p>
</li>
<li>
<p>第二种，使用内核自带的 XDP 技术，在网络包进入内核协议栈前，就对其进行处理，这样也可以实现很好的性能。</p>
</li>
</ul>
<h3 id="dns优化">dns优化</h3>
<p>dns解析服务的配置路径:  /etc/resolv.conf</p>
<ul>
<li>
<p>DNS 解析的结果进行缓存。缓存是最有效的方法，但要注意，一旦缓存过期，还是要去 DNS 服务器重新获取新记录。不过，这对大部分应用程序来说都是可接受的。</p>
</li>
<li>
<p>DNS 解析的结果进行预取。这是浏览器等 Web 应用中最常用的方法，也就是说，不等用户点击页面上的超链接，浏览器就会在后台自动解析域名，并把结果缓存起来。</p>
</li>
<li>
<p>使用 HTTPDNS 取代常规的 DNS 解析。这是很多移动应用会选择的方法，特别是如今域名劫持普遍存在，使用 HTTP 协议绕过链路中的 DNS 服务器，就可以避免域名劫持的问题。</p>
</li>
<li>
<p>基于 DNS 的全局负载均衡（GSLB）。这不仅为服务提供了负载均衡和高可用的功能，还可以根据用户的位置，返回距离最近的 IP 地址。</p>
</li>
</ul>
<h3 id="性能测试相关工具简介">性能测试相关工具简介</h3>
<p>在应用层，你可以使用 wrk、Jmeter,ab 等模拟用户的负载，测试应用程序的每秒请求数、处理延迟、错误数等；</p>
<p>而在传输层，则可以使用 iperf 等工具，测试 TCP 的吞吐情况；</p>
<p>再向下，你还可以用 Linux 内核自带的 pktgen ，测试服务器的 PPS。</p>
<h3 id="DDos检测">DDos检测</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n -p | grep SYN_REC | <span class="built_in">wc</span> -l</span><br><span class="line">193</span><br></pre></td></tr></table></figure>
<p>半连接队列容量设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  sysctl -w net.ipv4.tcp_max_syn_backlog=1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br></pre></td></tr></table></figure>
<p>TCP SYN Cookies 也是一种专门防御 SYN Flood 攻击的方法。SYN Cookies 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_syncookies=1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure>
<h3 id="相关配置选项">相关配置选项</h3>
<p><img src="en-resource://database/948:1" alt="5f2d4957663dd8bf3410da8180ab18f0.png"><br>
为 TCP 连接设置 TCP_NODELAY 后，就可以禁用 Nagle 算法；<br>
为 TCP 连接开启 TCP_CORK 后，可以让小包聚合成大包后再发送（注意会阻塞小包的发送）；<br>
使用 SO_SNDBUF 和 SO_RCVBUF ，可以分别调整套接字发送缓冲区和接收缓冲区的大小。</p>
<p><img src="en-resource://database/951:1" alt="b07ea76a8737ed93395736795ede44e0.png"></p>
<h3 id="相关命令-4">相关命令</h3>
<p><img src="en-resource://database/954:1" alt="a118911721f9b67ce9c83de15666753f.png"><br>
<img src="en-resource://database/961:1" alt="5dde213baffd7811ab73c82883b2a75d.png"></p>
<h4 id="tcpdump">tcpdump</h4>
<p>tcpdump可以帮助我们抓取线上的网络请求,更好的帮助我们定位相关的性能问题.</p>
<p><strong>根据 IP 地址反查域名、根据端口号反查协议名称，是很多网络工具默认的行为，而这往往会导致性能工具的工作缓慢。所以，通常，网络性能工具都会提供一个选项（比如 -n 或者 -nn），来禁止名称解析。</strong><br>
<img src="en-resource://database/947:1" alt="859d3b5c0071335429620a3fcdde4fff.png"></p>
<p><img src="evernotecid://8BF4008B-52C0-484E-A4B5-8EBD45F20215/appyinxiangcom/13973009/ENResource/p2047" alt="4870a28c032bdd2a26561604ae2f7cb3.png"></p>
<h4 id="ifconfig">ifconfig</h4>
<p>ifconfig可以查看网卡相关的统计信息.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr FA:16:3E:BD:06:39</span><br><span class="line">          inet addr:10.101.36.170  Bcast:10.101.36.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::f816:3eff:febd:639/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4057858883 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1585169869 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:4040200834350 (3.6 TiB)  TX bytes:241429911346 (224.8 GiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1318332868 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1318332868 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:222720162104 (207.4 GiB)  TX bytes:222720162104 (207.4 GiB)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="netstat-ss">netstat ss</h4>
<p>netstat命令已经在新的发行版本中的Linux中已经废弃,替代的命令为ss.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -ntlp</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:446                 0.0.0.0:*                   LISTEN      -</span><br><span class="line">tcp        0      0 0.0.0.0:798                 0.0.0.0:*                   LISTEN      -</span><br></pre></td></tr></table></figure>
<p>接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。当然还要注意，在不同套接字状态下，它们的含义不同。<br>
当套接字处于连接状态（Established）时，</p>
<ul>
<li>Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。</li>
<li>Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。<br>
当套接字处于监听状态（Listening）时，</li>
<li>Recv-Q 表示 syn backlog 的当前值。</li>
<li>Send-Q 表示最大的 syn backlog 值。<br>
而 syn backlog 是 TCP 协议栈中的半连接队列长度，相应的也有一个全连接队列（accept queue），它们都是维护 TCP 状态的重要机制。</li>
</ul>
<h4 id="sar">sar</h4>
<p>-n 参数就可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sar -n DEV</span></span><br><span class="line">03:08:23 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">03:08:24 PM     xgbe0  35393.00  17730.00  38886.97   8639.70      0.00      0.00      0.00</span><br><span class="line">03:08:24 PM        lo   7325.00   7325.00  15672.54  15672.54      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</p>
<p>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</p>
<p>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</p>
<p>%ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</p>
<h4 id="ping">ping</h4>
<p>ping这个命令工具一般都很常用.用来测试网络的连通性.这里不做过多的介绍</p>
<h2 id="监控方法">监控方法</h2>
<h3 id="USE方法">USE方法</h3>
<p>使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。</p>
<p>饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 的饱和度，表示资源无法接受更多的请求。</p>
<p>错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。<br>
<img src="en-resource://database/953:1" alt="ccd7a9350c270c0168bad6cc8d0b8aee.png"></p>
<h3 id="应用程序监控指标">应用程序监控指标</h3>
<p>第一个，是应用进程的资源使用情况，比如进程占用的 CPU、内存、磁盘 I/O、网络等。使用过多的系统资源，导致应用程序响应缓慢或者错误数升高，是一个最常见的性能问题。</p>
<p>第二个，是应用程序之间调用情况，比如调用频率、错误数、延时等。由于应用程序并不是孤立的，如果其依赖的其他应用出现了性能问题，应用自身性能也会受到影响。</p>
<p>第三个，是应用程序内部核心逻辑的运行情况，比如关键环节的耗时以及执行过程中的错误等。由于这是应用程序内部的状态，从外部通常无法直接获取到详细的性能数据。所以，应用程序在设计和开发时，就应该把这些指标提供出来，以便监控系统可以了解其内部运行状态。</p>
<h2 id="应用程序优化-2">应用程序优化</h2>
<p>第一，从 CPU 使用的角度来说，简化代码、优化算法、异步处理以及编译器优化等，都是常用的降低 CPU 使用率的方法，这样可以利用有限的 CPU 处理更多的请求。</p>
<p>第二，从数据访问的角度来说，使用缓存、写时复制、增加 I/O 尺寸等，都是常用的减少磁盘 I/O 的方法，这样可以获得更快的数据处理速度。</p>
<p>第三，从内存管理的角度来说，使用大页、内存池等方法，可以预先分配内存，减少内存的动态分配，从而更好地内存访问性能。</p>
<p>第四，从网络的角度来说，使用 I/O 多路复用、长连接代替短连接、DNS 缓存等方法，可以优化网络 I/O 并减少网络请求数，从而减少网络延时带来的性能问题。</p>
<p>第五，从进程的工作模型来说，异步处理、多线程或多进程等，可以充分利用每一个 CPU 的处理能力，从而提高应用程序的吞吐能力。</p>
<h2 id="动态追踪监测工具">动态追踪监测工具</h2>
<p><img src="en-resource://database/952:1" alt="5a2b2550547d5eaee850bfb806f76625.png"></p>
<h2 id="基准测试工具">基准测试工具</h2>
<p><img src="en-resource://database/962:1" alt="f094f489049602e1058e02edc708e6e9.png"></p>
<h2 id="附录">附录</h2>
<p>bctools相关的命令需要重新安装.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y bcc-tools libbcc-examples linux-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="next" href="/liuzexin.github.io/2024/10/19/kmp/">KMP算法-php实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://liuzexin.github.io/liuzexin.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpg"/></a><p>Stay foolish, stay hungry.</p><a class="info-icon" href="https://github.com/liuzexin" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://blog.csdn.net/lzx_victory?type=blog" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/liuzexin.github.io/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">线程,进程,协程</a> <a href="/liuzexin.github.io/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/linux-performance/">Linux 性能分析</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2024/10/19/kmp/">KMP算法-php实现</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2022/01/10/go-must-know-key-knowlage/">Go语言必须需要掌握的相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/11/20/manacher/">Manacher算法</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/10/17/algorithm/">算法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/liuzexin.github.io/2021/09/17/tcp-nagle/">TCP Nagle 与TCP Delayed ACK性能调研</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/liuzexin.github.io/." rel="nofollow">Eddison.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/liuzexin.github.io/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/liuzexin.github.io/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/liuzexin.github.io/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/liuzexin.github.io/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/liuzexin.github.io/js/smartresize.js?v=1.0.0"></script></div></body></html>